<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>STARK MARK XI | NANOSPACE</title>
    <style>
        :root { --iron-blue: #00f2ff; --repulsor-red: #ff3c00; --panel-bg: rgba(0, 15, 25, 0.85); }
        body { margin: 0; background: #000; color: var(--iron-blue); font-family: 'Orbitron', sans-serif; overflow: hidden; touch-action: none; }
        
        /* JARVIS HUD UI */
        #hud { position: absolute; inset: 0; pointer-events: none; border: 1px solid rgba(0, 242, 255, 0.1); z-index: 100; }
        .glass-panel {
            position: absolute; top: 20px; left: 20px; width: 280px; padding: 20px;
            background: var(--panel-bg); backdrop-filter: blur(15px);
            border-left: 4px solid var(--iron-blue); border-radius: 0 10px 10px 0;
            pointer-events: auto; box-shadow: 0 0 30px rgba(0,0,0,0.5);
        }
        #status-light { display: inline-block; width: 10px; height: 10px; border-radius: 50%; background: grey; margin-right: 5px; }
        .active { background: var(--iron-blue) !important; box-shadow: 0 0 10px var(--iron-blue); }
        .warning { background: var(--repulsor-red) !important; box-shadow: 0 0 10px var(--repulsor-red); }

        #init-btn {
            background: transparent; border: 1px solid var(--iron-blue); color: var(--iron-blue);
            width: 100%; padding: 12px; cursor: pointer; font-family: 'Orbitron'; font-weight: bold;
            margin-top: 15px; letter-spacing: 2px; transition: 0.3s;
        }
        #init-btn:hover { background: var(--iron-blue); color: #000; }

        #video-preview {
            position: absolute; bottom: 20px; right: 20px; width: 150px;
            border-radius: 10px; border: 1px solid var(--iron-blue);
            transform: scaleX(-1); opacity: 0.4; pointer-events: none;
        }

        .scan-line { position: absolute; width: 100%; height: 2px; background: var(--iron-blue); opacity: 0.1; top: 0; animation: scan 4s linear infinite; }
        @keyframes scan { 0% { top: 0; } 100% { top: 100%; } }

        @media (max-width: 600px) { .glass-panel { width: 85%; top: 10px; left: 5%; } }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

    <div id="hud">
        <div class="scan-line"></div>
        <div class="glass-panel">
            <h1 style="margin: 0; font-size: 16px;">STARK INDUSTRIES</h1>
            <p style="font-size: 10px; opacity: 0.7;">NANOSPACE v11.0</p>
            <div id="log"><span id="status-light"></span> <span id="status-text">OFFLINE</span></div>
            
            <div style="margin-top: 15px; font-size: 11px; display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                <div>X: <span id="pos-x">0</span></div>
                <div>Y: <span id="pos-y">0</span></div>
                <div>PINCH: <span id="pinch-lvl">0%</span></div>
                <div>SHAPE: <span id="shape-name">CORE</span></div>
            </div>

            <button id="init-btn">CONNECT NEURAL LINK</button>
        </div>
    </div>

    <video id="video-preview" autoplay playsinline></video>

    <script type="importmap">
        { "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }}
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { Hands } from 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js';
        import { Camera } from 'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js';

        let scene, camera, renderer, composer, particles, material;
        let targetPinch = 0, currentPinch = 0;
        let targetRotation = { x: 0, y: 0 };

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1000);
            camera.position.z = 80;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.8, 0.4, 0.85);
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            composer.addPass(bloom);

            const count = 4000;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            for(let i=0; i<count*3; i++) positions[i] = (Math.random()-0.5) * 100;
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            material = new THREE.ShaderMaterial({
                uniforms: { uTime: {value: 0}, uPinch: {value: 0}, uColor: {value: new THREE.Color(0x00f2ff)} },
                vertexShader: `
                    uniform float uTime; uniform float uPinch;
                    void main() {
                        vec3 p = position;
                        float dist = length(p);
                        // Morphing logic
                        p *= (1.0 - uPinch * 0.85);
                        p.x += sin(uTime + p.z*0.2) * (1.0 + uPinch * 5.0);
                        p.y += cos(uTime + p.x*0.2) * (1.0 + uPinch * 5.0);
                        vec4 mvp = modelViewMatrix * vec4(p, 1.0);
                        gl_PointSize = (25.0 / -mvp.z) * (1.0 + uPinch * 2.0);
                        gl_Position = projectionMatrix * mvp;
                    }
                `,
                fragmentShader: `
                    uniform vec3 uColor;
                    void main() {
                        float r = distance(gl_PointCoord, vec2(0.5));
                        if(r > 0.5) discard;
                        gl_FragColor = vec4(uColor, 1.0 - r*2.0);
                    }
                `,
                transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
            });

            particles = new THREE.Points(geo, material);
            scene.add(particles);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
        }

        async function startJarvis() {
            const statusLight = document.getElementById('status-light');
            const statusText = document.getElementById('status-text');
            const video = document.getElementById('video-preview');
            
            statusText.innerText = "CALIBRATING...";
            statusLight.classList.add('active');

            try {
                const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
                hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });

                hands.onResults((res) => {
                    if(res.multiHandLandmarks && res.multiHandLandmarks[0]) {
                        statusText.innerText = "SYNCED";
                        const h = res.multiHandLandmarks[0];
                        
                        // Pinch = Compression
                        const pinch = Math.hypot(h[4].x - h[8].x, h[4].y - h[8].y);
                        targetPinch = pinch < 0.08 ? 1.0 : 0.0;
                        
                        // Repulsor Mode (Palm Open & Close to Screen)
                        const palmDist = Math.hypot(h[0].x - h[9].x, h[0].y - h[9].y);
                        if(palmDist > 0.15) {
                            material.uniforms.uColor.value.setHex(0xff3c00);
                            statusLight.classList.add('warning');
                        } else {
                            material.uniforms.uColor.value.setHex(0x00f2ff);
                            statusLight.classList.remove('warning');
                        }

                        targetRotation.y = (h[9].x - 0.5) * 4;
                        targetRotation.x = (h[9].y - 0.5) * 4;

                        document.getElementById('pos-x').innerText = h[9].x.toFixed(2);
                        document.getElementById('pos-y').innerText = h[9].y.toFixed(2);
                        document.getElementById('pinch-lvl').innerText = (targetPinch * 100) + "%";
                    }
                });

                const cam = new Camera(video, {
                    onFrame: async () => { await hands.send({image: video}); },
                    width: 640, height: 480
                });
                await cam.start();
                document.getElementById('init-btn').style.display = 'none';

            } catch (err) {
                statusText.innerText = "LINK FAILED";
                console.error(err);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            material.uniforms.uTime.value += 0.02;
            material.uniforms.uPinch.value = THREE.MathUtils.lerp(material.uniforms.uPinch.value, targetPinch, 0.1);
            
            particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, targetRotation.y, 0.05);
            particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, targetRotation.x, 0.05);
            
            composer.render();
        }

        document.getElementById('init-btn').onclick = startJarvis;
        init();
    </script>
</body>
</html>
